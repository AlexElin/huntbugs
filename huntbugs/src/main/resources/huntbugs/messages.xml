<?xml version="1.0" encoding="UTF-8"?>
<p:Messages
  xmlns:p="https://raw.githubusercontent.com/amaembo/huntbugs/master/huntbugs/src/main/resources/huntbugs"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="https://raw.githubusercontent.com/amaembo/huntbugs/master/huntbugs/src/main/resources/huntbugs messages.xsd">
  <!-- Some of these descriptions are taken from FindBugs project: http://findbugs.sourceforge.net/ -->
  <WarningList>
    <Warning Type="RoughConstantValue">
      <Title>Rough value of known constant is used</Title>
      <Description>Constant $NUMBER$ should be replaced with $REPLACEMENT$</Description>
      <LongDescription><![CDATA[Analysis found that constant value <code>$NUMBER$</code> is used which is close to the <code>$REPLACEMENT$</code>. 
   If <code>$REPLACEMENT$</code> was actually meant, it's better to use it instead for better precision and code clarity.]]></LongDescription>
    </Warning>
    <Warning Type="AbsoluteValueOfHashCode">
      <Title>Bad attempt to compute absolute value of signed 32-bit hashcode</Title>
      <Description>Bad attempt to compute absolute value of signed 32-bit hashcode in $METHOD$</Description>
      <LongDescription><![CDATA[This code generates a hashcode and then computes the absolute value of that hashcode.<br> 
    If the hashcode is <code>Integer.MIN_VALUE</code>, then the result will be negative as well (since <code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>). 
    One out of 2<sup>32</sup> strings have a hashCode of <code>Integer.MIN_VALUE</code>, including "polygenelubricants", "GydZG_" and "DESIGNING WORKHOUSES".]]></LongDescription>
    </Warning>
    <Warning Type="AbsoluteValueOfRandomInt">
      <Title>Bad attempt to compute absolute value of signed random integer</Title>
      <Description>Bad attempt to compute absolute value of signed random integer in $METHOD$</Description>
      <LongDescription><![CDATA[This code generates a random signed integer and then computes the absolute value of that random integer.<br> 
   If the number returned by the random number generator is <code>Integer.MIN_VALUE</code>, then the result will be negative as well (since <code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>). 
   (Same problem arised for long values as well).]]></LongDescription>
    </Warning>
    <Warning Type="ArrayHashCode">
      <Title>Invocation of hashCode() on an array</Title>
      <Description>Invocation of hashCode() on an array in $METHOD$</Description>
      <LongDescription><![CDATA[This code invokes <code>hashCode()</code> on an array. Calling <code>hashCode()</code> on an array returns the same value as <code>System.identityHashCode</code>, and ingores the contents and length of the array. If you need a <code>hashCode</code> that depends on the contents of an array <code>a</code>, use <code>java.util.Arrays.hashCode(a)</code>. ]]></LongDescription>
    </Warning>
    <Warning Type="ArrayToString">
      <Title>Invocation of toString() on an array</Title>
      <Description>Invocation of toString() on an array in $METHOD$</Description>
      <LongDescription><![CDATA[The code invokes <code>toString()</code> on an array or implicitly converts an array into String. 
    This will generate a fairly useless result such as <code>[C@16f0472</code>. 
    Consider using <code>java.util.Arrays.toString</code> to convert the array into a readable String that gives the contents of the array.]]></LongDescription>
    </Warning>
    <Warning Type="StreamToString">
      <Title>Invocation of toString() on a Stream</Title>
      <Description>Invocation of toString() on a Stream in $METHOD$</Description>
      <LongDescription><![CDATA[The code invokes <code>toString()</code> on a Stream object. 
    This will generate a fairly useless result such as <code>java.util.stream.ReferencePipeline&#36;Head@16f0472</code>.
    Probably it was intended to collect the stream like <code>collect(Collectors.joining())</code>.]]></LongDescription>
    </Warning>
    <Warning Type="FloatCompareToNaN">
      <Title>Useless attempt to compare floating point number to NaN</Title>
      <Description>Useless attempt to compare a $USED_TYPE$ number to NaN</Description>
      <LongDescription><![CDATA[The code compares a number of $USED_TYPE$ type to <code>NaN</code>.
    This comparison is useless as it always returns false. To check whether the number is NaN or not use $REPLACEMENT$.]]></LongDescription>
    </Warning>
    <Warning Type="MaxMinMethodReferenceForComparator">
      <Title>Invalid method reference is used as comparator</Title>
      <Description>A reference to $METHOD_REFERENCE$ is erroneously used as a comparator</Description>
      <LongDescription><![CDATA[The code uses a reference to $METHOD_REFERENCE$ method for <code>Comparator</code> interface.
   While this code compiles, $METHOD_REFERENCE$ does not actually fulfill a comparator contract, thus you might have incorrect result
   or exception at runtime. Probably you wanted to use <code>Comparator.naturalOrder()</code> or <code>Comparator.reverseOrder()</code> instead.]]></LongDescription>
    </Warning>
    <Warning Type="SelfAssignmentLocalInsteadOfField">
      <Title>Local variable is assigned to itself, and there is a field with an identical name</Title>
      <Description>Local variable $VARIABLE$ is assigned to itself while there is a field with an identical name.</Description>
      <LongDescription><![CDATA[This code assigns a local variable to itself like <code>$VARIABLE$ = $VARIABLE$</code> while there's a 
   field with the same name in the class. Probably <code>this.$VARIABLE$ = $VARIABLE$</code> was meant instead.]]></LongDescription>
    </Warning>
    <Warning Type="SelfAssignmentLocal">
      <Title>Local variable is assigned to itself</Title>
      <Description>Local variable $VARIABLE$ is assigned to itself in $METHOD$.</Description>
      <LongDescription><![CDATA[This code assigns a local variable to itself like <code>$VARIABLE$ = $VARIABLE$</code>. Probably something else was meant.]]></LongDescription>
    </Warning>
    <Warning Type="VolatileIncrement">
      <Title>An increment to a volatile field isn't atomic</Title>
      <Description>Non-atomic increment to a volatile field $FIELD$.</Description>
      <LongDescription><![CDATA[This code increments a volatile field $FIELD$. Such operation is not atomic, so increments could be lost under contention.
    Consider using <code>AtomicInteger</code> or <code>AtomicLong</code> instead.]]></LongDescription>
    </Warning>
    <Warning Type="VolatileMath">
      <Title>Non-atomic math operation is performed on volatile field</Title>
      <Description>Non-atomic operation is performed on volatile field $FIELD$.</Description>
      <LongDescription><![CDATA[This code updates a volatile field $FIELD$. Such operation is not atomic, so updates could be lost under contention.
    Consider using <code>AtomicInteger</code> or <code>AtomicLong</code> instead.]]></LongDescription>
    </Warning>
    <Warning Type="VolatileArray">
      <Title>Volatile array field is declared</Title>
      <Description>Field $FIELD$ is a volatile array.</Description>
      <LongDescription><![CDATA[Field $FIELD$ is a volatile array. However, reads and writes to array elements are not volatile,
      so cannot be safely updated from different threads. Consider using $REPLACEMENT$ instead.]]></LongDescription>
    </Warning>
    <Warning Type="InvalidMinMax">
      <Title>Incorrect combination of max and min</Title>
      <Description>Incorrect code: $OUTER_FUNC$($OUTER_NUMBER$, $INNER_FUNC$($INNER_NUMBER$, value)).</Description>
      <LongDescription><![CDATA[This code attempts to limit the value using incorrect sequence of max and min operations: <code>$OUTER_FUNC$($OUTER_NUMBER$, $INNER_FUNC$($INNER_NUMBER$, value))</code>.
    Such code will always produce the same result <code>$OUTER_NUMBER$</code> (or <code>NaN</code> if a value is NaN). It seems that <code>$INNER_FUNC$($OUTER_NUMBER$, $OUTER_FUNC$($INNER_NUMBER$, value))</code>
    was assumed instead.]]></LongDescription>
    </Warning>
    <Warning Type="NonShortCircuitDangerous">
      <Title>Potentially dangerous use of non-short-circuit logic</Title>
      <Description>Potentially dangerous use of non-short-circuit operation $OPERATION$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code uses non-short-circuit operation <code>$OPERATION$</code> rather than short-circuit equivalent <code>$REPLACEMENT$</code>. 
   In addition, it seem possible that, depending on the value of the left hand side, you might not want to evaluate the right hand side (because it would have side effects), could cause an exception or could be expensive.<br>
   Non-short-circuit logic causes both sides of the expression to be evaluated even when the result can be inferred from knowing the left-hand side. This can be less efficient and can result in errors if the left-hand side guards cases when evaluating the right-hand side can generate an error. 
   ]]></LongDescription>
    </Warning>
    <Warning Type="NonShortCircuit">
      <Title>Questionable use of non-short-circuit logic</Title>
      <Description>Questionable use of non-short-circuit operation $OPERATION$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code uses non-short-circuit operation <code>$OPERATION$</code> rather than short-circuit equivalent <code>$REPLACEMENT$</code>.<br>
   Non-short-circuit logic causes both sides of the expression to be evaluated even when the result can be inferred from knowing the left-hand side. This can be less efficient and can result in errors if the left-hand side guards cases when evaluating the right-hand side can generate an error. 
   ]]></LongDescription>
    </Warning>
    <Warning Type="RandomNextIntViaNextDouble">
      <Title>The nextDouble() or Math.random() method is used instead of nextInt()</Title>
      <Description>Random value obtained via $CALLED_METHOD$ and multiplication.</Description>
      <LongDescription><![CDATA[An integer random value is generated by multiplying result of $CALLED_METHOD$ to a number and casting the result to int. It's more performant to use
      dedicated method $REPLACEMENT$.]]></LongDescription>
    </Warning>
    <Warning Type="RandomDoubleToInt">
      <Title>Random value from 0 to 1 is coerced to the integer 0</Title>
      <Description>Random value obtained via $RETURN_VALUE_OF$ is coerced to the integer 0 in $METHOD$.</Description>
      <LongDescription><![CDATA[A double random value is generated via $RETURN_VALUE_OF$ and converted into integer. This method generates values from 0 to 1 (excluding), so the result of this conversion is always zero. 
      You probably want to multiply the random value by something else before coercing it to an integer, or use the $REPLACEMENT$ method. 
   ]]></LongDescription>
    </Warning>
    <Warning Type="RandomUsedOnlyOnce">
      <Title>Random object created and used only once</Title>
      <Description>A $RANDOM_TYPE$ object created and used only once in $METHOD$.</Description>
      <LongDescription><![CDATA[This code creates a $RANDOM_TYPE$ object, uses it to generate one random number, and then discards it. This produces mediocre quality random numbers and is inefficient. If possible, rewrite the code so that the $RANDOM_TYPE$ object is created once and saved, 
   and each time a new random number is required invoke a method on the existing $RANDOM_TYPE$ object to obtain it.]]></LongDescription>
    </Warning>
    <Warning Type="SelfAssignmentArrayElement">
      <Title>Array element is assigned to itself</Title>
      <Description>Array element is assigned to itself in $METHOD$.</Description>
      <LongDescription><![CDATA[This code assigns an array element to itself, directly or via an intermediate variable. Probably something else was meant.]]></LongDescription>
    </Warning>
    <Warning Type="SelfAssignmentField">
      <Title>Field is assigned to itself</Title>
      <Description>A field $FIELD$ is assigned to itself in $METHOD$.</Description>
      <LongDescription><![CDATA[This code assigns a field $FIELD$ to itself, directly or via an intermediate variable. Probably something else was meant.]]></LongDescription>
    </Warning>
    <Warning Type="BigDecimalConstructedFromInfiniteOrNaN">
      <Title>BigDecimal constructed from Infinity or NaN</Title>
      <Description>A BigDecimal object is constructed from $NUMBER$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code constructs a <code>BigDecimal</code> from <code>$NUMBER$</code>. This is not supported: a <code>NumberFormatException</code> will be thrown at runtime.]]></LongDescription>
    </Warning>
    <Warning Type="BigDecimalConstructedFromDouble">
      <Title>BigDecimal is constructed from double</Title>
      <Description>A BigDecimal object is constructed from $DOUBLE_NUMBER$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code uses <code>new BigDecimal($DOUBLE_NUMBER$)</code>. This method will create a <code>BigDecimal</code> object which corresponds to the exact decimal representation of
   given double-precision number, which is <code>$BIGDECIMAL_NUMBER$</code>. You probably wanted to use <code>BigDecimal.valueOf($DOUBLE_NUMBER$)</code> which would produce actually $DOUBLE_NUMBER$.]]></LongDescription>
    </Warning>
    <Warning Type="CompareBitAndIncompatible">
      <Title>Incompatible bit mask for bitwise and</Title>
      <Description>A (x &amp; $AND_OPERAND$) is compared to $COMPARED_TO$ which is always false.</Description>
      <LongDescription><![CDATA[This code compares <code>(x &amp; $AND_OPERAND$)</code> with <code>$COMPARED_TO$</code>. Regardless of <code>x</code> value the result of expression is never equal to <code>$COMPARED_TO$</code>
   due to incompatible bit mask.]]></LongDescription>
    </Warning>
    <Warning Type="CompareBitOrIncompatible">
      <Title>Incompatible bit mask for bitwise or</Title>
      <Description>A (x | $OR_OPERAND$) is compared to $COMPARED_TO$ which is always false.</Description>
      <LongDescription><![CDATA[This code compares <code>(x | $OR_OPERAND$)</code> with <code>$COMPARED_TO$</code>. Regardless of <code>x</code> value the result of expression is never equal to <code>$COMPARED_TO$</code>
   due to incompatible bit mask.]]></LongDescription>
    </Warning>
    <Warning Type="DoubleLongBitsToDoubleOnInt">
      <Title>Double.longBitsToDouble invoked on an int</Title>
      <Description>Double.longBitsToDouble invoked on an int in $METHOD$.</Description>
      <LongDescription><![CDATA[This code invokes $RETURN_VALUE_OF$ method, but a 32 bit int value is passed as an argument. This almostly certainly is not intended and is unlikely to give the intended result.]]></LongDescription>
    </Warning>
    <Warning Type="NonAtomicOperationOnConcurrentMap">
      <Title>Non-atomic sequence of operations on ConcurrentMap</Title>
      <Description>$SECOND_METHOD$ is called after $FIRST_METHOD$ in non-atomical manner.</Description>
      <LongDescription><![CDATA[This code invokes $SECOND_METHOD$ method to update the key in concurrent map after invoking $FIRST_METHOD$ to check the same key.
   This sequence is not atomic, so it's possible that concurrent thread updates the same key meanwhile and several objects associated with the same key will be used concurrently.<br>
   As a better alternative consider using <code>putIfAbsent</code> or <code>replace</code> methods.]]></LongDescription>
    </Warning>
    <Warning Type="RemOne">
      <Title>Integer remainder modulo 1</Title>
      <Description>Integer remainder modulo one in $METHOD$.</Description>
      <LongDescription><![CDATA[The <code>(x % 1)</code> expression is computed here which always returns zero. Probably <code>(x & 1)</code> or <code>(x % 2)</code> was meant.]]></LongDescription>
    </Warning>
    <Warning Type="ResultOfComparisonIsStaticallyKnownDeadCode">
      <Title>Result of comparison is statically known resulting in dead code</Title>
      <Description>A comparison $LEFT_OPERAND$ $OPERATION$ $RIGHT_OPERAND$ is always $RESULT$ which results in dead code.</Description>
      <LongDescription><![CDATA[This code performs a comparison <code>$LEFT_OPERAND$ $OPERATION$ $RIGHT_OPERAND$</code> which is statically known to be $RESULT$.
        As a result some branch or the next condition in short-circuiting chain will never be executed. Probably something else was meant or 
        this comparison along with the dead branch could be deleted.]]></LongDescription>
    </Warning>
    <Warning Type="ResultOfComparisonIsStaticallyKnown">
      <Title>Result of comparison is statically known</Title>
      <Description>A comparison $LEFT_OPERAND$ $OPERATION$ $RIGHT_OPERAND$ is always $RESULT$.</Description>
      <LongDescription><![CDATA[This code performs a comparison <code>$LEFT_OPERAND$ $OPERATION$ $RIGHT_OPERAND$</code> which is statically known to be $RESULT$.
        Probably something else was meant or this comparison could be deleted.]]></LongDescription>
    </Warning>
    <Warning Type="SameConditionsExcluding">
      <Title>The same condition is repeatedly checked resulting in dead code</Title>
      <Description>The same condition is repeatedly checked resulting in dead code in $METHOD$.</Description>
      <LongDescription><![CDATA[This code checks the same condition twice. As a result some branch is never executed. Probably there's logical error or typo in the code.]]></LongDescription>
    </Warning>
    <Warning Type="SameConditions">
      <Title>The same condition is repeatedly checked</Title>
      <Description>The same condition is repeatedly checked in $METHOD$.</Description>
      <LongDescription><![CDATA[This code checks the same condition twice. Probably there's logical error or typo in the code.]]></LongDescription>
    </Warning>
    <Warning Type="SelfComparison">
      <Title>The expression is compared with itself</Title>
      <Description>The expression is compared with itself in $METHOD$.</Description>
      <LongDescription><![CDATA[The expression is compared with itself like <code>(x $OPERATION$ x)</code> which does not make sense. Probably there's logical error or typo in the code.]]></LongDescription>
    </Warning>
    <Warning Type="SelfEquals">
      <Title>The equals() method is called for the same expression</Title>
      <Description>The equals() method is called for the same expression in $METHOD$.</Description>
      <LongDescription><![CDATA[The expression is compared with itself like <code>x.equals(x)</code> which does not make sense. Probably there's logical error or typo in the code.]]></LongDescription>
    </Warning>
    <Warning Type="SelfComputation">
      <Title>The operand is repeating in computation making it nonsensical</Title>
      <Description>The operation like x $OPERATION$ x is performed in $METHOD$.</Description>
      <LongDescription><![CDATA[This code performs an operation like <code>(x $OPERATION$ x)</code>. The result of this operation is 
   always the same regardless the value of <code>x</code> (not considering the NaNs). Probably there's logical error or typo in the code.]]></LongDescription>
    </Warning>
    <Warning Type="UnnecessaryInstanceOfInferred">
      <Title>The instanceof check is found to be unnecessary</Title>
      <Description>Unnecessary instanceof $INSTANCEOF_TYPE$ is detected in $METHOD$.</Description>
      <LongDescription><![CDATA[This code performs an <code>instanceof $INSTANCEOF_TYPE:plain$</code> check. However it's statically known that 
   the expression type is always $INFERRED_TYPE$, so this check is always true.<br> 
   Probably something else was meant or this check could be replaced with zero check or removed at all.]]></LongDescription>
    </Warning>
    <Warning Type="UnnecessaryInstanceOf">
      <Title>The instanceof check is unnecessary</Title>
      <Description>Unnecessary instanceof $INSTANCEOF_TYPE$ is performed in $METHOD$.</Description>
      <LongDescription><![CDATA[This code performs an <code>instanceof $INSTANCEOF_TYPE:plain$</code> check. However this check is always true as the expression
   type is $ACTUAL_TYPE$.<br>
   Probably something else was meant or this check could be replaced with zero check or removed at all.]]></LongDescription>
    </Warning>
    <Warning Type="SameBranchesTernary">
      <Title>The ternary operator has identical branches</Title>
      <Description>The ternary operator has identical branches in $METHOD$.</Description>
      <LongDescription><![CDATA[Both true and false branches of <code>?:</code> ternary operator has the same code. Probably there's logical error or typo in the code.]]></LongDescription>
    </Warning>
    <Warning Type="SameBranchesIf">
      <Title>The if operator has identical branches</Title>
      <Description>The if operator has identical branches in $METHOD$.</Description>
      <LongDescription><![CDATA[Both true and false branches of <code>if</code> operator has the same code. Probably there's logical error or typo in the code.]]></LongDescription>
    </Warning>
    <Warning Type="SameBranchesSwitch">
      <Title>The switch operator has identical branches</Title>
      <Description>Two or more switch branches have identical code in $METHOD$.</Description>
      <LongDescription><![CDATA[Two or more switch branches have identical code. Probably there's logical error or typo in the code. If everything is correct, consider
   merging these branches together.]]></LongDescription>
    </Warning>
    <Warning Type="SameBranchesSwitchDefault">
      <Title>The switch operator branch is identical to the default code</Title>
      <Description>The switch operator branch is identical to the default code in $METHOD$.</Description>
      <LongDescription><![CDATA[One or more switch branches have the same code as the default branch (or the code which follows the switch statement). Probably there's logical error or typo in the code. If everything is correct, consider
   removing these branches as the same code will be executed anyways.]]></LongDescription>
    </Warning>
    <Warning Type="FinalizeOnlyNullsFields">
      <Title>The finalize() method only nulls fields</Title>
      <Description>The $METHOD$ method only nulls fields.</Description>
      <LongDescription><![CDATA[This finalizer does nothing except null out fields. This is completely pointless, and requires that the object be garbage collected, finalized, and then garbage collected again. You should just remove the finalize method.]]></LongDescription>
    </Warning>
    <Warning Type="FinalizeEmpty">
      <Title>The finalize() method is empty</Title>
      <Description>The $METHOD$ method is empty.</Description>
      <LongDescription><![CDATA[This finalizer does nothing and you can freely delete it.]]></LongDescription>
    </Warning>
    <Warning Type="FinalizePublic">
      <Title>The finalize() method is public</Title>
      <Description>The $METHOD$ method is public.</Description>
      <LongDescription><![CDATA[A $METHOD$ method should have protected access, not public.]]></LongDescription>
    </Warning>
    <Warning Type="FinalizeNullsFields">
      <Title>The finalize() method nulls fields</Title>
      <Description>The $METHOD$ method nulls out fields.</Description>
      <LongDescription><![CDATA[This finalizer nulls out fields. This is usually an error, as it does not aid garbage collection, and the object is going to be garbage collected anyway.]]></LongDescription>
    </Warning>
    <Warning Type="FinalizeNullifiesSuper">
      <Title>Finalizer nullifies superclass finalizer</Title>
      <Description>The $METHOD$ method nullifies superclass finalizer.</Description>
      <LongDescription><![CDATA[This empty $METHOD$ method explicitly negates the effect of any finalizer defined by its superclass $SUPERCLASS$.
      Any finalizer actions defined for the superclass will not be performed. Unless this is intended, delete this method.]]></LongDescription>
    </Warning>
    <Warning Type="FinalizeNoSuperCall">
      <Title>Finalizer does not call superclass finalizer</Title>
      <Description>The $METHOD$ method does not call superclass finalizer.</Description>
      <LongDescription><![CDATA[This $METHOD$ method does not make a call to its superclass's <code>finalize()</code> method. 
      So, finalizer actions defined for the superclass $SUPERCLASS$ will not be performed. Add a call to <code>super.finalize()</code>.]]></LongDescription>
    </Warning>
    <Warning Type="FinalizeUselessSuper">
      <Title>Finalizer does nothing except calling the superclass finalizer</Title>
      <Description>The $METHOD$ method does nothing except calling the superclass finalizer.</Description>
      <LongDescription><![CDATA[The only thing $METHOD$ does is calling the superclass <code>finalize()</code> method.
      This is redundant, so this method could be deleted.]]></LongDescription>
    </Warning>
    <Warning Type="ImpossibleToArrayDowncast">
      <Title>Impossible downcast of toArray() result</Title>
      <Description>Impossible downcast of toArray() result in $METHOD$.</Description>
      <LongDescription><![CDATA[This method casts the result of <code>toArray()</code> method to $TARGET_TYPE$. This will usually fail with <code>ClassCastException</code> as
      <code>toArray()</code> method returns an <code>Object[]</code> array for most of the collections.<br>
      The correct way to do this is <code>toArray(new $TARGET_ELEMENT_TYPE:plain$[0])</code>.]]></LongDescription>
    </Warning>
    <Warning Type="IntegerMultiplicationPromotedToLong">
      <Title>Result of integer multiplication promoted to long</Title>
      <Description>Integer multiplication by $NUMBER$ is promoted to long.</Description>
      <LongDescription><![CDATA[This method converts the result of integer multiplication to long like <code>long result = x * $NUMBER$</code>. Such operation, depending on the value of <code>x</code> might overflow
      as the multiplication is performed on 32-bit integers. Probably it was intended to cast before the multiplication like <code>long result = ((long)x) * $NUMBER$</code>.]]></LongDescription>
    </Warning>
    <Warning Type="IntegerDivisionPromotedToFloat">
      <Title>Result of integer division promoted to floating point type</Title>
      <Description>Result of $SOURCE_TYPE$ division is promoted to $TARGET_TYPE$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This method promotes the result of $SOURCE_TYPE$ division to $TARGET_TYPE$ like <code>$TARGET_TYPE$ result = $SOURCE_TYPE$Var / 2</code>. Probably it was intended to cast to the $TARGET_TYPE$ type before the division like
      <code>$TARGET_TYPE$ result = (($TARGET_TYPE$)$SOURCE_TYPE$Var) / 2</code>.]]></LongDescription>
    </Warning>
    <Warning Type="IntegerPromotionInCeilOrRound">
      <Title>An integer value is cast to float and passed to the rounding method</Title>
      <Description>A value of $SOURCE_TYPE$ type is promoted to $TARGET_TYPE$ and passed into $RETURN_VALUE_OF$.</Description>
      <LongDescription><![CDATA[This code tries to round the value which type is already integral, so the rounding operation will unlikely to have an effect. 
      Check the argument of $RETURN_VALUE_OF$.]]></LongDescription>
    </Warning>
    <Warning Type="WaitNotInLoop">
      <Title>Wait not in loop</Title>
      <Description>The $CALLED_METHOD$ method is called not in the loop in $METHOD$.</Description>
      <LongDescription><![CDATA[This method contains a call to $CALLED_METHOD$ which is not in a loop.  If the monitor is used for multiple conditions, the condition the caller intended to wait for might not be the one that actually occurred.]]></LongDescription>
    </Warning>
    <Warning Type="WaitUnconditional">
      <Title>Unconditional wait</Title>
      <Description>Unconditional $CALLED_METHOD$ call in $METHOD$.</Description>
      <LongDescription><![CDATA[This method contains a call to $CALLED_METHOD$ which is not guarded by conditional control flow.  The code should verify that condition it intends to wait for is not already satisfied before calling wait; any previous notifications will be ignored.]]></LongDescription>
    </Warning>
    <Warning Type="NotifyNaked">
      <Title>Naked call to notify() or notifyAll()</Title>
      <Description>Naked $CALLED_METHOD$ call in $METHOD$.</Description>
      <LongDescription><![CDATA[ A call to $CALLED_METHOD$ was made without any (apparent) accompanying modification to mutable object state.  In general, calling a notify method on a monitor is done because some condition another thread is waiting for has become true.  However, for the condition to be meaningful, it must involve a heap object that is visible to both threads.<br>
       This bug does not necessarily indicate an error, since the change to mutable object state may have taken place in a method which then called the method containing the notification.]]></LongDescription>
    </Warning>
    <Warning Type="FinalizeInvocation">
      <Title>Explicit invocation of finalizer</Title>
      <Description>Explicit invocation of finalize() in $METHOD$.</Description>
      <LongDescription><![CDATA[This method contains an explicit invocation of the <code>finalize()</code> method on an object. Because finalizer methods are supposed to be executed once, and only by the VM, this is a bad idea.<br>
        If a connected set of objects beings finalizable, then the VM will invoke the finalize method on all the finalizable object, 
        possibly at the same time in different threads. Thus, it is a particularly bad idea, in the finalize method for a class <code>X</code>, invoke finalize on objects referenced by <code>X</code>, because they may already be getting finalized in a separate thread.]]></LongDescription>
    </Warning>
    <Warning Type="SystemRunFinalizersOnExit">
      <Title>Method invokes runFinalizersOnExit()</Title>
      <Description>Invocation of $CALLED_METHOD$ in $METHOD$.</Description>
      <LongDescription><![CDATA[Never call $CALLED_METHOD$ for any reason. This method is deprecated and inherently unsafe.]]></LongDescription>
    </Warning>
    <Warning Type="SystemGc">
      <Title>Method invokes System.gc()</Title>
      <Description>Invocation of $CALLED_METHOD$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code explicitly invokes garbage collection. Except for specific use in benchmarking, this is very dubious.<br>
        In the past, situations where people have explicitly invoked the garbage collector in routines such as close or finalize methods has led to huge performance black holes. Garbage collection can be expensive. Any situation that forces hundreds or thousands of garbage collections will bring the machine to a crawl.]]></LongDescription>
    </Warning>
    <Warning Type="SystemExit">
      <Title>Method invokes System.exit()</Title>
      <Description>Invocation of $CALLED_METHOD$ in $METHOD$.</Description>
      <LongDescription><![CDATA[Invoking $CALLED_METHOD$ shuts down the entire Java virtual machine. This should only been done when it is appropriate. 
      Such calls make it hard or impossible for your code to be invoked by other code. Consider throwing a <code>RuntimeException</code> instead.]]></LongDescription>
    </Warning>
    <Warning Type="ThreadStopThrowable">
      <Title>Method invokes Thread.stop(Throwable)</Title>
      <Description>Invocation of $CALLED_METHOD$ in $METHOD$.</Description>
      <LongDescription><![CDATA[The $CALLED_METHOD$ method is inherently unsafe and deprecated. Since Java 8 it just throws <code>UnsupportedOperationException</code>.]]></LongDescription>
    </Warning>
    <Warning Type="URLBlockingMethod">
      <Title>The equals and hashCode methods of URL are blocking</Title>
      <Description>A $RETURN_VALUE_OF$ is called which may unexpectedly perform a network request.</Description>
      <LongDescription><![CDATA[This code calls $RETURN_VALUE_OF$ method. Such method may perform a DNS request to resolve the domain name which
      may result in unexpected performance hit. Consider using <code>java.net.URI</code> instead.]]></LongDescription>
    </Warning>
    <Warning Type="UselessAndWithMinusOne">
      <Title>Useless bitwise-and operation with -1</Title>
      <Description>Useless bitwise-and with -1 ($NUMBER:hex$) in $METHOD$.</Description>
      <LongDescription><![CDATA[This code performs bit operation like <code>(x &amp; $NUMBER:hex$)</code>. Such operation is useless as the result is always <code>x</code>.]]></LongDescription>
    </Warning>
    <Warning Type="UselessOrWithZero">
      <Title>Useless or/xor operation with 0</Title>
      <Description>Useless or/xor with 0 in $METHOD$.</Description>
      <LongDescription><![CDATA[This code performs bit operation like <code>(x $OPERATION$ 0)</code>. Such operation is useless as the result is always <code>x</code>.]]></LongDescription>
    </Warning>
    <Warning Type="UselessAndWithZero">
      <Title>Useless bitwise-and operation with 0</Title>
      <Description>Useless bitwise-and with 0 in $METHOD$.</Description>
      <LongDescription><![CDATA[This code performs bit operation like <code>(x &amp; 0)</code>. Such operation is useless as the result is always zero.]]></LongDescription>
    </Warning>
    <Warning Type="UselessThread">
      <Title>A thread was created using the default empty run() method</Title>
      <Description>A thread was created using the default empty run() method in $METHOD$.</Description>
      <LongDescription><![CDATA[This code creates a thread without specifying a <code>run()</code> method either by deriving from the <code>Thread</code> class, or by passing a <code>Runnable</code> object. Thus this thread does nothing.]]></LongDescription>
    </Warning>
    <Warning Type="BooleanConstructor">
      <Title>Inefficient Boolean constructor</Title>
      <Description>Inefficient Boolean constructor is invoked in $METHOD$.</Description>
      <LongDescription><![CDATA[This code creates new instances of <code>Boolean</code> class which is just a waste of memory. Only two different <code>Boolean</code> objects are necessary:
      <code>Boolean.TRUE</code> and <code>Boolean.FALSE</code>. Use $REPLACEMENT$ method which returns one of them.]]></LongDescription>
    </Warning>
    <Warning Type="NumberConstructor">
      <Title>Inefficient number constructor</Title>
      <Description>Inefficient $TARGET_TYPE$ constructor is invoked in $METHOD$.</Description>
      <LongDescription><![CDATA[This code creates new instances of $TARGET_TYPE$ class using the constructor. It's usually preferred to use $REPLACEMENT$ method which
      may return cached object reducing memory usage.]]></LongDescription>
    </Warning>
    <Warning Type="StringConstructor">
      <Title>Inefficient string constructor</Title>
      <Description>Inefficient String(string) constructor is invoked in $METHOD$.</Description>
      <LongDescription><![CDATA[This code creates new instances of <code>String</code> class using <code>new String(string)</code>. This is completely unnecessary as the resulting string is indistinguishable from the original string.<br>
      Before Java 7u6 this could be meaningful to save some memory if the original string was created using the <code>substring()</code>.
      However currently such operation only wastes memory. Simply use the original string instead.]]></LongDescription>
    </Warning>
    <Warning Type="StringConstructorEmpty">
      <Title>Inefficient empty string constructor</Title>
      <Description>Inefficient String() constructor is invoked in $METHOD$.</Description>
      <LongDescription><![CDATA[This code creates new instances of empty <code>String</code> using <code>new String()</code>. This is completely unnecessary and just wastes memory.
      Simply use <code>""</code>: you will get the shared instance of empty string.]]></LongDescription>
    </Warning>
    <Warning Type="StringToString">
      <Title>Unnecessary call to String.toString() method</Title>
      <Description>Unnecessary call to $CALLED_METHOD$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code calls $CALLED_METHOD$ method. This is unnecessary as it just returns the original string.
      Simply use the original string.]]></LongDescription>
    </Warning>
    <Warning Type="HashCodeNoEquals">
      <Title>Class defines hashCode() but not equals()</Title>
      <Description>The class $TYPE$ defines hashCode() but not equals().</Description>
      <LongDescription><![CDATA[This class defines a $METHOD$ method but not an <code>equals()</code> method.
      Instead, the $SUPER_METHOD$ defined in superclass will be used.
      Therefore, the class may violate the invariant that equal objects must have equal hashcodes.]]></LongDescription>
    </Warning>
    <Warning Type="HashCodeObjectEquals">
      <Title>Class defines hashCode() and uses Object.equals()</Title>
      <Description>The class $TYPE$ defines hashCode() and uses Object.equals().</Description>
      <LongDescription><![CDATA[This class defines a $METHOD$ method but inherits its <code>equals()</code> method 
      from <code>java.lang.Object</code> (which defines equality by comparing object references).
      Although this will probably satisfy the contract that equal objects must have equal hashcodes, 
      it is probably not what was intended by overriding the <code>hashCode()</code> method.
      Overriding hashCode() implies that the object's identity is based on criteria more complicated than simple reference equality.]]></LongDescription>
    </Warning>
    <Warning Type="EqualsNoHashCode">
      <Title>Class defines equals() but not hashCode()</Title>
      <Description>The class $TYPE$ defines equals() but not hashCode().</Description>
      <LongDescription><![CDATA[This class defines a $METHOD$ method but not a <code>hashCode()</code> method.
      Instead, the $SUPER_METHOD$ defined in superclass will be used.
      Therefore, the class may violate the invariant that equal objects must have equal hashcodes.]]></LongDescription>
    </Warning>
    <Warning Type="EqualsObjectHashCode">
      <Title>Class defines equals() and uses Object.hashCode()</Title>
      <Description>The class $TYPE$ defines equals() and uses Object.hashCode().</Description>
      <LongDescription><![CDATA[This class defines a $METHOD$ method but inherits its <code>hashCode()</code> method 
      from <code>java.lang.Object</code> (which returns the identity hash code, an arbitrary value assigned to the object by the VM).
      Therefore, the class is very likely to violate the invariant that equal objects must have equal hashcodes.
      If you don't think instances of this class will ever be inserted into a <code>HashMap/HashSet</code>, the recommended hashCode implementation to use is:
      
<pre>public int hashCode() {
   assert false : "hashCode not designed";
   return 42; // any arbitrary constant will do
}</pre>]]></LongDescription>
    </Warning>
    <Warning Type="EqualsReturnsFalse">
      <Title>The equals() method always returns false</Title>
      <Description>The $METHOD$ method always returns false.</Description>
      <LongDescription><![CDATA[This class defines an <code>equals()</code> method that always returns false. This means that an object is not equal to itself, and it is impossible to create useful Maps or Sets of this class. 
        More fundamentally, it means that equals is not reflexive, one of the requirements of the equals method.<br>
        The likely intended semantics are object identity: that an object is equal to itself. This is the behavior inherited from class Object. If you need to override an equals inherited from a different superclass, you can use use:<br>
        <code>public boolean equals(Object o) { return this == o; }</code>
      ]]></LongDescription>
    </Warning>
    <Warning Type="EqualsReturnsTrue">
      <Title>The equals() method always returns true</Title>
      <Description>The $METHOD$ method always returns true.</Description>
      <LongDescription><![CDATA[This class defines an equals method that always returns true. This is imaginative, but not very smart. 
      In addition, it means that the equals method is not symmetric.</code>
      ]]></LongDescription>
    </Warning>
    <Warning Type="EqualsClassNames">
      <Title>The equals() method compares class names</Title>
      <Description>The $METHOD$ method compares class names.</Description>
      <LongDescription><![CDATA[This method checks to see if two objects are the same class by checking to see if the names of their classes are equal. You can have different classes with the same name if they are loaded by different class loaders. 
      Just check to see if the class objects are the same like <code>this.getClass() == other.getClass()</code>.
      ]]></LongDescription>
    </Warning>
    <Warning Type="EqualsOther">
      <Title>The equals() method defined that doesn't override equals(Object)</Title>
      <Description>The $METHOD$ method doesn't override $NORMAL_EQUALS$.</Description>
      <LongDescription><![CDATA[The $METHOD$ method doesn't override $NORMAL_EQUALS$. Probably this is a mistake.]]></LongDescription>
    </Warning>
    <Warning Type="EqualsSelf">
      <Title>The covariant equals() method defined that doesn't override equals(Object)</Title>
      <Description>The covariant $METHOD$ method doesn't override $NORMAL_EQUALS$.</Description>
      <LongDescription><![CDATA[The covariant $METHOD$ method is defined which doesn't override $NORMAL_EQUALS$. Probably this is a mistake.]]></LongDescription>
    </Warning>
    <Warning Type="EqualsEnum">
      <Title>The covariant equals() method defined for enum</Title>
      <Description>The covariant $METHOD$ method is defined for enum.</Description>
      <LongDescription><![CDATA[This class defines an enumeration, and equality on enumerations is defined using object identity. 
      Defining a covariant equals method $METHOD$ for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally.]]></LongDescription>
    </Warning>
    <Warning Type="WrongMapIterator">
      <Title>Inefficient use of keySet() iterator instead of entrySet() iterator</Title>
      <Description>Inefficient use of keySet() iterator instead of entrySet() iterator in $METHOD$.</Description>
      <LongDescription><![CDATA[This method accesses the value of a <code>Map</code> entry, using a key that was retrieved from a <code>keySet()</code> iterator. 
      It is more efficient to use an iterator on the $REPLACEMENT$ of the map, to avoid the <code>Map.get(key)</code> lookup.<br>
      In Java-8 you may also consider using <code>Map.forEach()</code> method.
      ]]></LongDescription>
    </Warning>
    <Warning Type="WrongMapIteratorValues">
      <Title>Inefficient use of keySet() iterator instead of values() iterator</Title>
      <Description>Inefficient use of keySet() iterator instead of values() iterator in $METHOD$.</Description>
      <LongDescription><![CDATA[This method accesses the <code>Map</code> values, using a key that was retrieved from a <code>keySet()</code> iterator.
      It's detected that map key is not used for any purpose other than getting map value. It would be shorter and more efficient to iterate
      over $REPLACEMENT$ instead.]]></LongDescription>
    </Warning>
    <Warning Type="ExposeMutableStaticFieldViaParameter">
      <Title>Internal static state exposure by storing a mutable object into a static field</Title>
      <Description>Internal static state exposure by storing an object of $FIELD_TYPE$ type into a $FIELD$.</Description>
      <LongDescription><![CDATA[This method stores a parameter into a static field $FIELD$. However the field type is $FIELD_TYPE$
      which allows uncontrolled modification by the caller. Consider copying an object before storing it in the field.]]></LongDescription>
    </Warning>
    <Warning Type="ExposeMutableFieldViaParameter">
      <Title>Internal state exposure by storing a mutable object into a field</Title>
      <Description>Internal state exposure by storing an object of $FIELD_TYPE$ type into a $FIELD$.</Description>
      <LongDescription><![CDATA[This method stores a parameter into a field $FIELD$. However the field type is $FIELD_TYPE$
      which allows uncontrolled modification by the caller. Consider copying an object before storing it in the field.]]></LongDescription>
    </Warning>
    <Warning Type="NewForGetClass">
      <Title>Method allocates an object, only to get the class object</Title>
      <Description>Method creates an object of type $OBJECT_TYPE$ just to get the class object.</Description>
      <LongDescription><![CDATA[This method retrieves the class object like this: <code>new $OBJECT_TYPE:plain$().getClass()</code>.
      Allocating the object is completely unnecessary here. Simply writing <code>$OBJECT_TYPE:plain$.class</code> is more performant.]]></LongDescription>
    </Warning>
    <Warning Type="EmptyBranch">
      <Title>Empty branch or control flow statement</Title>
      <Description>Empty branch or control flow statement in $METHOD$.</Description>
      <LongDescription><![CDATA[An empty control flow statement is found. Probably something else was meant or this statement could be deleted.]]></LongDescription>
    </Warning>
    <Warning Type="ArrayReturnNull">
      <Title>Method returns null instead of empty array</Title>
      <Description>$METHOD$ returns null instead of empty array.</Description>
      <LongDescription><![CDATA[It is often a better design to return a length zero array rather than a <code>null</code> reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.]]></LongDescription>
    </Warning>
    <Warning Type="BooleanReturnNull">
      <Title>Method with Boolean return type returns explicit null</Title>
      <Description>Method $METHOD$ with $RETURN_TYPE$ return type returns null.</Description>
      <LongDescription><![CDATA[A method that returns either <code>Boolean.TRUE</code>, <code>Boolean.FALSE</code> or <code>null</code> is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, 
      and the compiler will insert automatic unboxing of the $RETURN_TYPE$ value. If a <code>null</code> value is returned, this will result in a <code>NullPointerException</code>.]]></LongDescription>
    </Warning>
    <Warning Type="OptionalReturnNull">
      <Title>Method with Optional return type returns explicit null</Title>
      <Description>Method $METHOD$ with $RETURN_TYPE$ return type returns null.</Description>
      <LongDescription><![CDATA[The usage of $RETURN_TYPE$ return type always mean that explicit <code>null</code> returns were not desired by design. 
      Returning a <code>null</code> value in such case is a contract violation and will most likely break clients code.]]></LongDescription>
    </Warning>
    <Warning Type="BadNameOfMethod">
      <Title>Method names should start with a lower case letter</Title>
      <Description>Name of the method $METHOD$ violates the convention.</Description>
      <LongDescription><![CDATA[Methods should be named in mixed case (camel-case) with the first letter lowercase and the first letter of each internal word capitalized.]]></LongDescription>
    </Warning>
    <Warning Type="BadNameOfMethodSameAsConstructor">
      <Title>Method is named like constructor</Title>
      <Description>Method $METHOD$ was probably intended to be a constructor.</Description>
      <LongDescription><![CDATA[This regular method $METHOD$ has the same name as the class it is defined in. 
      It is likely that this was intended to be a constructor.
      If it was intended to be a constructor, remove the declaration of a void return value.
      If you had accidentally defined this method, realized the mistake, defined a proper constructor but can't get rid of this method due to backwards compatibility, deprecate the method.]]></LongDescription>
    </Warning>
    <Warning Type="BadNameOfField">
      <Title>Field names should start with a lower case letter</Title>
      <Description>Name of the field $FIELD$ violates the convention.</Description>
      <LongDescription><![CDATA[Names of fields that are not final should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized.]]></LongDescription>
    </Warning>
    <Warning Type="BadNameOfClass">
      <Title>Class names should start with an upper case letter</Title>
      <Description>Name of the class $TYPE$ violates the convention.</Description>
      <LongDescription><![CDATA[Class names should be nouns, in mixed case with the first letter of each internal word capitalized. Try to keep your class names simple and descriptive. Use whole words-avoid acronyms and abbreviations (unless the abbreviation is much more widely used than the long form, such as URL or HTML).]]></LongDescription>
    </Warning>
    <Warning Type="BadNameOfClassSameAsSuperclass">
      <Title>Class simple name is identical to superclass simple name</Title>
      <Description>$TYPE$ simple name is the same as superclass simple name.</Description>
      <LongDescription><![CDATA[This class $TYPE$ has a simple name that is identical to that of its superclass $SUPERCLASS$, except that its superclass is in a different package.
      This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidentally define methods that do not override methods in their superclasses.]]></LongDescription>
    </Warning>
    <Warning Type="BadNameOfClassSameAsInterface">
      <Title>Class simple name is identical to interface simple name</Title>
      <Description>$TYPE$ simple name is the same as interface simple name.</Description>
      <LongDescription><![CDATA[This class or interface $TYPE$ has a simple name that is identical to that of the implemented interface $INTERFACE$, except that the superinterface is in a different package.
      This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidentally define methods that do not override methods in their superclasses.]]></LongDescription>
    </Warning>
    <Warning Type="BadNameOfClassException">
      <Title>Class is not derived from an Exception, even though it is named as such</Title>
      <Description>$TYPE$ ends with Exception, but does not inherit Throwable.</Description>
      <LongDescription><![CDATA[The class $TYPE$ is not derived from another <code>Exception</code> or even <code>Throwable</code>, but ends with 'Exception'. This will be confusing to users of this class.]]></LongDescription>
    </Warning>
    <Warning Type="FloatComparison">
      <Title>Test for floating point equality</Title>
      <Description>Test for floating point equality in $METHOD$.</Description>
      <LongDescription><![CDATA[This operation compares two floating point values for equality. 
      Because floating point calculations may involve rounding, calculated float and double values may not be accurate.<br>
      For values that must be precise, such as monetary values, consider using a fixed-precision type such as <code>BigDecimal</code>.
      For values that need not be precise, consider comparing for equality within some range, for example: <code>if ( Math.abs(x - y) < .0000001 )</code>.]]></LongDescription>
    </Warning>
    <Warning Type="StartInConstructor">
      <Title>Constructor invokes Thread.start()</Title>
      <Description>Constructor invokes $CALLED_METHOD$ in $TYPE$.</Description>
      <LongDescription><![CDATA[The constructor starts a thread. This is likely to be wrong if the class is ever extended/subclassed, since the thread will be started before the subclass constructor is started.]]></LongDescription>
    </Warning>
    <Warning Type="UnsafeGetResource">
      <Title>Class.getResource() may return unexpected results in subclasses</Title>
      <Description>$RETURN_VALUE_OF$ method may return unexpected results in subclasses.</Description>
      <LongDescription><![CDATA[This code calls <code>this.getClass().$RETURN_VALUE_OF:name$(resource)</code>. If this class is extended in another package,
      <code>this.getClass()</code> will return another class and this call will likely to fail.<br>
      Consider replacing this code with <code>$TYPE:plain$.class.$RETURN_VALUE_OF:name$(resource)</code>. If this class is not supposed to be extended, declare it as <code>final</code>.]]></LongDescription>
    </Warning>
    <Warning Type="HashCodeRemainder">
      <Title>Remainder of hashCode() is used as index</Title>
      <Description>Remainder of $RETURN_VALUE_OF$ is used as index in $METHOD$.</Description>
      <LongDescription><![CDATA[This code computes a hashCode, and then computes the remainder of that value modulo another value like <code>(x.hashCode() % n)</code>. Since the hashCode can be negative, the result of the remainder operation can also be negative.
      The result is then used as index which must be non-negative, so this code may fail with <code>IndexOutOfBoundsException</code>.<br>
      You may fix this code using <code>Math.abs(x.hashCode() % n)</code> instead.]]></LongDescription>
    </Warning>
    <Warning Type="RandomIntRemainder">
      <Title>Remainder of Random.nextInt() is used as index</Title>
      <Description>Remainder of $RETURN_VALUE_OF$ is used as index in $METHOD$.</Description>
      <LongDescription><![CDATA[This code computes a random integer, and then computes the remainder of that value modulo another value like <code>($RETURN_VALUE_OF:plain$ % n)</code>. 
      Since the $RETURN_VALUE_OF$ may return negative value, the result of the remainder operation can also be negative.
      The result is then used as index which must be non-negative, so this code may fail with <code>IndexOutOfBoundsException</code>.<br>
      You may fix this code using <code>nextInt(n)</code> instead.]]></LongDescription>
    </Warning>
    <Warning Type="StaticFieldFromInstanceMethod">
      <Title>Write to static field from instance method</Title>
      <Description>Instance method $METHOD$ writes to static field $FIELD$.</Description>
      <LongDescription><![CDATA[This instance method writes to a static field $FIELD$. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.]]></LongDescription>
    </Warning>
    <Warning Type="CatchIllegalMonitorStateException">
      <Title>Dubious catching of IllegalMonitorStateException</Title>
      <Description>Dubious catching of IllegalMonitorStateException in $METHOD$.</Description>
      <LongDescription><![CDATA[$EXCEPTION$ is generally only thrown in case of a design flaw in your code (calling wait or notify on an object you do not hold a lock on).
      Normally it should not be catched.]]></LongDescription>
    </Warning>
    <Warning Type="CatchConcurrentModificationException">
      <Title>Dubious catching of ConcurrentModificationException</Title>
      <Description>Dubious catching of ConcurrentModificationException in $METHOD$.</Description>
      <LongDescription><![CDATA[$EXCEPTION$ is generally only thrown in case of a design flaw in your code (concurrent modification of the collection which is not thread-safe).
      Normally it should not be catched.]]></LongDescription>
    </Warning>
    <Warning Type="BitCheckGreater">
      <Title>Check for sign of bitwise operation result</Title>
      <Description>Check for sign like (x &amp; $NUMBER:hex$) &gt; 0 in $METHOD$.</Description>
      <LongDescription><![CDATA[This condition checks the sign of the result of bitwise operation like <code>(x & $NUMBER:hex$) &gt; 0</code>.
      It's better to use equality check: <code>(x & $NUMBER:hex$) != 0</code> as if bit mask will later change, it may have the high bit set producing the negative result.]]></LongDescription>
    </Warning>
    <Warning Type="BitCheckGreaterNegative">
      <Title>Check for sign of bitwise operation result with high bit</Title>
      <Description>Check for sign like (x &amp; $NUMBER:hex$) &gt; 0 may produce incorrect result.</Description>
      <LongDescription><![CDATA[This condition checks the sign of the result of bitwise operation like <code>(x & $NUMBER:hex$) &gt; 0</code>.
      However the <code>$NUMBER:hex$</code> has the high bit set, thus it's actually negative number ($NUMBER:dec$). The result of this comparison
      could be negative as well which is likely to be unexpected here. Consider replacing with equality check: <code>(x & $NUMBER:hex$) != 0</code>.]]></LongDescription>
    </Warning>
    <Warning Type="BoxedForToString">
      <Title>Unnecessary boxing to convert a value to string</Title>
      <Description>$BOXED_TYPE$ object is created just for toString() call in $METHOD$.</Description>
      <LongDescription><![CDATA[This method tries to convert a value to string using the pattern like <code>new $BOXED_TYPE:plain$(val).toString()</code>
      or <code>(($BOXED_TYPE:plain$)val).toString()</code>. Creating boxed object is completely unnecessary here. 
      Though in some cases the object could be optimized out by JIT-compiler, it's still better to use $REPLACEMENT$ method instead:
      <code>String.valueOf(val)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="BoxedForUnboxing">
      <Title>Unnecessary boxing to convert a value back to primitive</Title>
      <Description>$BOXED_TYPE$ object is created just for unboxing in $METHOD$.</Description>
      <LongDescription><![CDATA[This method unnecessarily creates $BOXED_TYPE$ object which is used for unboxing only. This is unnecessary and may impact the performance.
      Just use primitive type instead.]]></LongDescription>
    </Warning>
    <Warning Type="UnboxedForBoxing">
      <Title>A boxed object is unboxed just for subsequent boxing</Title>
      <Description>$BOXED_TYPE$ object is unboxed just for subsequent boxing in $METHOD$.</Description>
      <LongDescription><![CDATA[This method unnecessarily unboxes the $BOXED_TYPE$ object which is used for subsequent boxing only.
      This is inefficient as additional objects might be allocated which are exact copies of the original object. Consider using the boxed type all the way.]]></LongDescription>
    </Warning>
    <Warning Type="MethodTooLarge">
      <Title>Method body is too large for detailed analysis</Title>
      <Description>$METHOD$ body is too larget for details analysis.</Description>
      <LongDescription><![CDATA[Method $METHOD$ bytecode size is $BYTECODE_SIZE$ bytes which is bigger than current limit $LIMIT$ set for bytecode analysis.
      As a result the method body is not analysed.]]></LongDescription>
    </Warning>
    <Warning Type="BadNameOfMethodMistake">
      <Title>Probably the method was mistakenly named</Title>
      <Description>Probably $REPLACEMENT:name$() was intended instead of $METHOD:name$().</Description>
      <LongDescription><![CDATA[This class defines a method called <code>$METHOD:name$()</code>. This method does not override the $REPLACEMENT$, which is probably what was intended.]]></LongDescription>
    </Warning>
    <Warning Type="NegatingComparatorResult">
      <Title>Dangerous comparison result negation</Title>
      <Description>The result of $CALLED_METHOD$ is negated.</Description>
      <LongDescription><![CDATA[This code negates a result of $CALLED_METHOD$. The comparison method contract allows to return any integer value, including <code>Integer.MIN_VALUE</code>
      which sign will not change after negation. It's safer to use <code>b.compareTo(a)</code> instead of <code>-a.compareTo(b)</code> and
      <code>comparator.compare(b, a)</code> instead of <code>-comparator.compare(a, b)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="ComparingComparatorResultWithNumber">
      <Title>Comparison result is checked against specific number</Title>
      <Description>The result of $CALLED_METHOD$ is compared with $NUMBER$.</Description>
      <LongDescription><![CDATA[This code compares the result of $CALLED_METHOD$ with $NUMBER$. The comparison method contract allows to return any number, so you should not check against
      specific constants. Instead check the sign of the comparison result.]]></LongDescription>
    </Warning>
    <Warning Type="DroppedException">
      <Title>Exception created and dropped rather than thrown</Title>
      <Description>Exception $EXCEPTION$ is created and dropped.</Description>
      <LongDescription><![CDATA[This code creates an exception (or error) object of type $EXCEPTION$, but doesn't do anything with it.
      Probably the <code>throw</code> keyword is missing.]]></LongDescription>
    </Warning>
    <Warning Type="IgnoredException">
      <Title>Exception is ignored</Title>
      <Description>Exception $EXCEPTION$ is ignored in $METHOD$.</Description>
      <LongDescription><![CDATA[This code ignores any exception of type $EXCEPTION$. This is dangerous as may mask
      programming errors or internal VM errors and make your program silently behaving incorrectly.]]></LongDescription>
    </Warning>
    <Warning Type="ScheduledThreadPoolExecutorChangePoolSize">
      <Title>Futile attempt to change max pool size of ScheduledThreadPoolExecutor</Title>
      <Description>Callind $CALLED_METHOD$ has no effect for $ARG_TYPE$.</Description>
      <LongDescription><![CDATA[This code tries to change max pool size calling $CALLED_METHOD$. However this method has no effect for $ARG_TYPE$ as this thread pool
      acts as fixed-sized pool.]]></LongDescription>
    </Warning>
    <Warning Type="AppendObjectOutputStream">
      <Title>Attempt to append to an object output stream</Title>
      <Description>Attempt to append to an object output stream in $METHOD$.</Description>
      <LongDescription><![CDATA[This code opens a file in append mode and then wraps the result in an $OOS_TYPE$. This won't allow you to append to an existing $OOS_TYPE$ stored in a file. If you want to be able to append to an object output stream, you need to keep the object output stream open.<br>
      The only situation in which opening a file in append mode and the writing an $OOS_TYPE$ could work is if on reading the file you plan to open it in random access mode and seek to the byte offset where the append started.]]></LongDescription>
    </Warning>
    <Warning Type="AndEqualsAlwaysFalse">
      <Title>Two conditions cannot be true simultaneously</Title>
      <Description>A condition like (x.equals($CONST1$) &amp;&amp; x.equals($CONST2$)) is never true.</Description>
      <LongDescription><![CDATA[This code checks that the same expression is simultaneously equal to two different values <code>$CONST1$</code> and <code>$CONST2$</code>.
      This condition is never true. Probably it was intended to use || instead of &amp;&amp;.]]></LongDescription>
    </Warning>
    <Warning Type="OrNotEqualsAlwaysTrue">
      <Title>One of two conditions is always true</Title>
      <Description>A condition like (!x.equals($CONST1$) || !x.equals($CONST2$)) is always true.</Description>
      <LongDescription><![CDATA[This code checks that the same expression is either not equal to <code>$CONST1$</code> or not equal to <code>$CONST2$</code>.
      This condition is always true. Probably it was intended to use &amp;&amp; instead of ||.]]></LongDescription>
    </Warning>
    <Warning Type="DateBadMonth">
      <Title>Bad constant value for month</Title>
      <Description>$CALLED_METHOD$ is called with incorrect argument $NUMBER$.</Description>
      <LongDescription><![CDATA[A $CALLED_METHOD$ is called, but the argument $NUMBER$ is out of range: it should be from 0 (January) to 11 (December).]]></LongDescription>
    </Warning>
    <Warning Type="UselessStringSubstring">
      <Title>Useless String.substring(0)</Title>
      <Description>Passing 0 to $RETURN_VALUE_OF$ is useless.</Description>
      <LongDescription><![CDATA[A $RETURN_VALUE_OF$ is called like <code>str.$RETURN_VALUE_OF:name$(0)</code>. This is useless as the resulting string
      will be the same as the original one. Remove this call.]]></LongDescription>
    </Warning>
    <Warning Type="StringIndexIsLessThanZero">
      <Title>String index is less than zero</Title>
      <Description>Negative index or length $INDEX$ is passed to $RETURN_VALUE_OF$.</Description>
      <LongDescription><![CDATA[Negative index or length $INDEX$ is passed to $RETURN_VALUE_OF$ which will result in <code>IndexOutOfBoundsException</code> at runtime.]]></LongDescription>
    </Warning>
    <Warning Type="StringIndexIsGreaterThanAllowed">
      <Title>String index is too big</Title>
      <Description>Index $INDEX$ passed to $RETURN_VALUE_OF$ exceeds maximum possible value of $MAX_VALUE$.</Description>
      <LongDescription><![CDATA[Index or length $INDEX$ passed to $RETURN_VALUE_OF$ exceeds $MAX_VALUE$ which will result in <code>IndexOutOfBoundsException</code> at runtime.]]></LongDescription>
    </Warning>
    <Warning Type="ComparatorIsNotSerializable">
      <Title>Comparator is not serializable</Title>
      <Description>Comparator $TYPE$ doesn't implement $SHOULD_IMPLEMENT$.</Description>
      <LongDescription><![CDATA[The $TYPE$ class implements the <code>Comparator</code> interface. Consider implementing also $SHOULD_IMPLEMENT$ interface.<br>
      If a comparator is used to construct an ordered collection such as a <code>TreeMap</code>, then the <code>TreeMap</code> will be serializable only if the comparator is also serializable. 
      As most comparators have little or no state, making them serializable is generally easy and good defensive programming. ]]></LongDescription>
    </Warning>
    <Warning Type="SerialVersionUidNotStatic">
      <Title>The serialVersionUID field is not static</Title>
      <Description>The $FIELD$ is not static.</Description>
      <LongDescription><![CDATA[This class defines a $FIELD$ that is not static.
       The field should be made static if it is intended to specify the version UID for purposes of serialization.]]></LongDescription>
    </Warning>
    <Warning Type="SerialVersionUidNotFinal">
      <Title>The serialVersionUID field is not final</Title>
      <Description>The $FIELD$ is not final.</Description>
      <LongDescription><![CDATA[This class defines a $FIELD$ that is not final.
       The field should be made final if it is intended to specify the version UID for purposes of serialization.]]></LongDescription>
    </Warning>
    <Warning Type="SerialVersionUidNotLong">
      <Title>The serialVersionUID field type is not long</Title>
      <Description>The $FIELD$ must be of long type.</Description>
      <LongDescription><![CDATA[This class defines a $FIELD$ which type is <code>int</code>.
       The field type should be changed to <code>long</code> if it is intended to specify the version UID for purposes of serialization.]]></LongDescription>
    </Warning>
    <Warning Type="RedundantInterface">
      <Title>Class implements the same interface as superclass</Title>
      <Description>Class $TYPE$ implements $INTERFACE$ which is already implemented by superclass.</Description>
      <LongDescription><![CDATA[The $TYPE$ class declares that it implements an interface $INTERFACE$ that is also implemented by a superclass. This is redundant because once a superclass implements an interface, all subclasses by default also implement this interface.]]></LongDescription>
    </Warning>
    <Warning Type="IteratorHasNextCallsNext">
      <Title>The hasNext() method invokes next()</Title>
      <Description>Method $METHOD$ invokes $RETURN_VALUE_OF$.</Description>
      <LongDescription><![CDATA[The iterator method $METHOD$ invokes $RETURN_VALUE_OF$. This is almost certainly wrong, since the <code>hasNext()</code> method is not supposed to change the state of the iterator, and the <code>next()</code> method is supposed to change the state of the iterator.]]></LongDescription>
    </Warning>
    <Warning Type="IteratorNoThrow">
      <Title>The next() iterator method does not throw NoSuchElementException</Title>
      <Description>The $METHOD$ method does not throw NoSuchElementException.</Description>
      <LongDescription><![CDATA[It looks like the method $METHOD$ does not throw <code>NoSuchElementException</code>. By iterator contract it must throw this exception when there are no
      elements left.]]></LongDescription>
    </Warning>
    <Warning Type="BitShiftInvalidAmount">
      <Title>Suspicious bit count in bit shift operation</Title>
      <Description>Bit shift operation (x $OPERATION$ $NUMBER$) has suspicious bit count.</Description>
      <LongDescription><![CDATA[This code performs a bit shift like <code>(x $OPERATION$ $NUMBER$)</code> where number of bits is not in the (0..$MAX_VALUE$) range.
      In this case only lower bits will be used (e.g. <code>val &gt;&gt; 70</code> is equal to <code>val &gt;&gt; 6</code>). Probably something else was meant here.]]></LongDescription>
    </Warning>
    <Warning Type="BitAddSignedByte">
      <Title>Adding a signed byte to the value with low 8 bits clear</Title>
      <Description>Adding a signed byte to the value with low 8 bits clear in $METHOD$.</Description>
      <LongDescription><![CDATA[This code adds a signed byte value to another value which has low 8 bits clear like <code>(x << 8) + byteValue</code>.
      Probably it was intended to add unsigned byte value like <code>(x << 8) + (byteValue &amp; 0xFF)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="BitOrSignedByte">
      <Title>Bitwise or with a signed byte</Title>
      <Description>Bitwise or with a signed byte in $METHOD$.</Description>
      <LongDescription><![CDATA[This code performs bitwise or of a signed byte value with another value which has low 8 bits clear like <code>(x << 8) | byteValue</code>.
      Usually this is a mistake as if byteValue is negative, it will be widened to <code>0xFFFFFFbb</code> and higher bits
      will be affected as well. Probably it was intended to use unsigned byte value like <code>(x << 8) | (byteValue &amp; 0xFF)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="ComparisonWithOutOfRangeValue">
      <Title>Numeric comparison is always true or false</Title>
      <Description>Numeric comparison like (x $OPERATION$ $NUMBER$) is always $RESULT$.</Description>
      <LongDescription><![CDATA[This code performs a comparison like (x $OPERATION$ $NUMBER$). However due to the value type or previous operations it's known that <code>x = $MIN_VALUE$..$MAX_VALUE$</code>,
      thus the result of this comparison is always $RESULT$. Probably there's some logic error or typo.]]></LongDescription>
    </Warning>
    <Warning Type="SwitchBranchUnreachable">
      <Title>Switch branch is unreachable due to expression range</Title>
      <Description>Unreachable switch branch "case $NUMBER$".</Description>
      <LongDescription><![CDATA[The <code>case $NUMBER$:</code> switch branch will never be executed, because it's statically known that
      switch expression range is <code>$MIN_VALUE$..$MAX_VALUE$</code>. Probably there's some logic error or typo.]]></LongDescription>
    </Warning>
    <Warning Type="RegexBadSyntax">
      <Title>Incorrect syntax of regular expression</Title>
      <Description>Incorrect syntax of regular expression $REGEXP:const$.</Description>
      <LongDescription><![CDATA[This code uses a regular expression <code>$REGEXP:const$</code> which has the following syntax error:<br>
      <pre>$ERROR_MESSAGE$</pre>]]></LongDescription>
    </Warning>
    <Warning Type="RegexUnintended">
      <Title>"." or "|" used for regular expression</Title>
      <Description>$REGEXP:const$ is used for regular expression.</Description>
      <LongDescription><![CDATA[This code uses a regular expression <code>$REGEXP:const$</code>. Such regular expression is mostly useless. 
      Probably <code>"\\$REGEXP$"</code> was intended instead.]]></LongDescription>
    </Warning>
    <Warning Type="RegexFileSeparator">
      <Title>File separator is used for regular expression</Title>
      <Description>File separator is used for regular expression in $METHOD$.</Description>
      <LongDescription><![CDATA[This code uses file separator as a regular expression. This will fail on Windows platforms, where the <code>File.separator</code> is a backslash, 
      which is interpreted in a regular expression as an escape character.<br>
      To fix this code you may use <code>Pattern.quote(File.separator)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="ParameterOverwritten">
      <Title>Argument is not used and overwritten</Title>
      <Description>Argument $VARIABLE$ is not used and overwritten in $METHOD$.</Description>
      <LongDescription><![CDATA[This code method accepts an argument $VARIABLE$, but its initial value
      is not used and overwritten in the method. This may indicate a logical error in the program.]]></LongDescription>
    </Warning>
    <Warning Type="IncorrectConcurrentMethod">
      <Title>Using monitor style wait methods on java.util.concurrent abstraction</Title>
      <Description>Method $CALLED_METHOD:name$() is called on $TARGET$ type.</Description>
      <LongDescription><![CDATA[This code calls $CALLED_METHOD$ on object of $TARGET$ type. Probably the correspoding concurrency API method
      like $REPLACEMENT$ was intended. Even if this code is written as intended, this is a bad practice and might be extremely confusing for
      other developers.]]></LongDescription>
    </Warning>
    <Warning Type="SynchronizationOnBoolean">
      <Title>Synchronization on Boolean</Title>
      <Description>Synchronization on $MONITOR_TYPE$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code synchronizes on a boxed $MONITOR_TYPE$ value. Since there normally exist only two Boolean objects, this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness and possible deadlock.]]></LongDescription>
    </Warning>
    <Warning Type="SynchronizationOnBoxedNumber">
      <Title>Synchronization on boxed number</Title>
      <Description>Synchronization on $MONITOR_TYPE$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code synchronizes on a boxed $MONITOR_TYPE$ value. Since $MONITOR_TYPE$ objects can be cached and shared, this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness and possible deadlock.]]></LongDescription>
    </Warning>
    <Warning Type="SynchronizationOnUnsharedBoxed">
      <Title>Synchronization on unshared boxed value</Title>
      <Description>Synchronization on newly-created $MONITOR_TYPE$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code synchronizes on a newly-created $MONITOR_TYPE$ value. 
      This may work correctly, but confusing and prone to errors. For example, applying automatic refactoring IDE feature like 'Remove unnecessary boxing'
      may silently break your code. It's much better to use <code>new Object()</code> as a lock variable.]]></LongDescription>
    </Warning>
    <Warning Type="EmptySynchronizeBlock">
      <Title>Empty synchronization block</Title>
      <Description>Empty synchronization block in $METHOD$.</Description>
      <LongDescription><![CDATA[This code contains empty synchronization block. This is almost always a bug: it's hardly possible that such block
      serves its purpose.]]></LongDescription>
    </Warning>
    <Warning Type="SpinLoopOnField">
      <Title>Spin loop on non-volatile field</Title>
      <Description>Spin loop on non-volatile field $FIELD$.</Description>
      <LongDescription><![CDATA[This code spins in a loop which reads a field $FIELD$. 
      The compiler may legally hoist the read out of the loop, turning the code into an infinite loop.  
      The class should be changed so it uses proper synchronization (including wait and notify calls).]]></LongDescription>
    </Warning>
    <Warning Type="StringConcatInLoop">
      <Title>String concatenation in a loop</Title>
      <Description>Variable $VARIABLE$ is concatenated in loop.</Description>
      <LongDescription><![CDATA[This code concatenates a string (stored in variable <code>$VARIABLE$</code>) in a loop. This could be really inefficient. Consider using <code>StringBuilder</code> instead.]]></LongDescription>
    </Warning>
    <Warning Type="SwingMethodNotInSwingThread">
      <Title>Certain swing methods needs to be invoked in Swing thread</Title>
      <Description>Swing method $CALLED_METHOD$ is not invoked in the Swing thread.</Description>
      <LongDescription><![CDATA[This code calls $CALLED_METHOD$ not in the Swing thread. 
      The Swing methods show(), setVisible(), and pack() will create the associated peer for the frame. With the creation of the peer, the system creates the event dispatch thread. This makes things problematic because the event dispatch thread could be notifying listeners while pack and validate are still processing. This situation could result in two threads going through the Swing component-based GUI -- it's a serious flaw that could result in deadlocks or other related threading issues. A pack call causes components to be realized. As they are being realized (that is, not necessarily visible), they could trigger listener notification on the event dispatch thread.]]></LongDescription>
    </Warning>
    <Warning Type="ConvertCaseWithDefaultLocale">
      <Title>Case conversion is performed with system-default locale</Title>
      <Description>Case conversion method $RETURN_VALUE_OF$ is called with system-default locale.</Description>
      <LongDescription><![CDATA[This code calls $RETURN_VALUE_OF$. The result of this method may vary depending on system-default locale.
      For example, in Turkish locale <code>"point".toUpperCase()</code> becomes <code>PO&#304;NT</code> which is undesired in many cases, especially in server
      environment.<br>
      Consider using the special method $REPLACEMENT$ which accepts a <code>Locale</code> argument. For example, if English case conversion rules are desired, use
      <code>$REPLACEMENT:name$(Locale.ENGLISH)</code>. Even if system-default locale is desired it's better to use <code>$REPLACEMENT:name$(Locale.getDefault())</code>
      to explicitly manifest this.]]></LongDescription>
    </Warning>
    <Warning Type="MethodReliesOnDefaultEncoding">
      <Title>Method relies on default encoding</Title>
      <Description>The called constructor or method $RETURN_VALUE_OF$ relies on default encoding.</Description>
      <LongDescription><![CDATA[This code calls $RETURN_VALUE_OF$. The called method or constructor relies on system-default encoding which
      might be inappropriate, especially on server applications. Consider using another method which allows to specify the encoding explicitly
      either with string (like <code>"UTF-8"</code>) or with <code>Charset</code> object (like <code>StandardCharsets.UTF_8</code>).]]></LongDescription>
    </Warning>
    <Warning Type="InfiniteRecursion">
      <Title>Infinite recursion is detected</Title>
      <Description>Infinite recursion is detected in $METHOD$.</Description>
      <LongDescription><![CDATA[This method calls itself in a way that will likely to cause infinite recursion and <code>StackOverflowError</code>.
      Probably there's some logical mistake here.]]></LongDescription>
    </Warning>
    <Warning Type="InfiniteLoop">
      <Title>Infinite loop is detected</Title>
      <Description>Infinite loop is detected in $METHOD$.</Description>
      <LongDescription><![CDATA[This method defines a loop with non-trivial condition which is unlikely to change.
      So this loop can finish only exceptionally. Probably there's some error in the code. If such behavior is intended 
      consider defining infinite loop more explicitly like <code>while(true)</code> or <code>for(;;)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="InvariantLoopCondition">
      <Title>Invariant loop condition</Title>
      <Description>Invariant loop condition in $METHOD$.</Description>
      <LongDescription><![CDATA[This non-trivial condition defined in a loop is unlikely to change over the loop iterations.
      Probably there's some error in the code. If such behavior is intended 
      consider moving the condition out of the loop or using explicitly infinite loop like <code>while(true)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="InvariantLoopConditionPart">
      <Title>Invariant part of loop condition</Title>
      <Description>Invariant part of loop condition in $METHOD$.</Description>
      <LongDescription><![CDATA[The part of loop condition which involves variable <code>$VARIABLE$</code> is unlikely to change over the loop iterations.
      Probably there's some error in the code. If such behavior is intended 
      consider moving the condition out of the loop for code clarity.]]></LongDescription>
    </Warning>
    <Warning Type="CollectionAddedToItself">
      <Title>Collection added to itself</Title>
      <Description>Collection is added to itself in $METHOD$.</Description>
      <LongDescription><![CDATA[This code adds a collection to itself. This is dangerous as after that collection might work badly. For example,
      calling <code>hashCode</code> on it may throw <code>StackOverflowError</code>.]]></LongDescription>
    </Warning>
    <Warning Type="PrimitiveArrayPassedAsVarArg">
      <Title>Primitive array is passed as var-arg</Title>
      <Description>Primitive array is passed to $CALLED_METHOD$ where var-arg is expected.</Description>
      <LongDescription><![CDATA[This code calls $CALLED_METHOD$ and passes a primitive array of type $ARRAY_TYPE$ where var-arg argument is expected.
      The primitive array will be wrapped into one-element object array which is likely a mistake.]]></LongDescription>
    </Warning>
    <Warning Type="CheckForOddnessFailsForNegative">
      <Title>Check for oddness may fail for negative input</Title>
      <Description>Check for oddness like (x % 2 $OPERATION$ 1) may fail for negative input.</Description>
      <LongDescription><![CDATA[This code checks for oddness using pattern like <code>(x % 2 $OPERATION$ 1)</code>. This would fail if
      <code>x</code> happens to be negative. Even if it's impossible in your case the error-proof practice is to replace this code with
      <code>(x % 2 $REPLACEMENT$ 0)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="AverageComputationCouldOverflow">
      <Title>Average computation could overflow</Title>
      <Description>Average computation could overflow in $METHOD$.</Description>
      <LongDescription><![CDATA[This code computes average array index in a way which could cause signed integer overflow if sum of indices
      exceeds 2<sup>31</sup>. To compute average index safely use unsigned right shift: <code>((low + high) &gt;&gt;&gt; 1)</code>]]></LongDescription>
    </Warning>
    <Warning Type="AnnotationNoRuntimeRetention">
      <Title>Useless reflection call for an annotation without RUNTIME retention</Title>
      <Description>Call to $RETURN_VALUE_OF$ will have no effect as $ANNOTATION$ has no runtime retention.</Description>
      <LongDescription><![CDATA[This code calls <code>$RETURN_VALUE_OF:name$($ANNOTATION:name$.class)</code>. However the annotation $ANNOTATION$ is
      not visible to reflection as it does not annotated with <code>@Retention(RetentionPolicy.RUNTIME)</code>.]]></LongDescription>
    </Warning>
    <Warning Type="DeadStoreInReturn">
      <Title>Useless local variable update in return statement</Title>
      <Description>Useless update of variable $VARIABLE$ in return statement.</Description>
      <LongDescription><![CDATA[This code updates local variable $VARIABLE$ and immediately returns. Updating local variable is useless here as the updated value is never used.
      Probably something else was meant here or assignment could be removed.]]></LongDescription>
    </Warning>
    <Warning Type="DeadIncrementInReturn">
      <Title>Useless increment of local variable in return statement</Title>
      <Description>Useless increment of variable $VARIABLE$ in return statement.</Description>
      <LongDescription><![CDATA[This code increments local variable $VARIABLE$ and immediately returns. Updating local variable is useless here as the updated value is never used.
      Probably something else was meant here or increment statement could be removed or replaced with addition.]]></LongDescription>
    </Warning>
    <Warning Type="DeadIncrementInAssignment">
      <Title>Increment result is nullified by assignment</Title>
      <Description>Useless increment in expression: $EXPRESSION$.</Description>
      <LongDescription><![CDATA[This code increments local variable $VARIABLE$ and immediately assigns it to the same variable
      like <code>$EXPRESSION$</code>. This makes the increment completely useless.]]></LongDescription>
    </Warning>
    <Warning Type="CloneableDoesNotImplementClone">
      <Title>Class implements Cloneable, but does not have clone() method</Title>
      <Description>Class $TYPE$ implements Cloneable, but does not have clone() method.</Description>
      <LongDescription><![CDATA[This class implements <code>Cloneable</code> interface, but does not have <code>clone()</code> method. Usually it's a mistake, especially if
      the class defines fields.]]></LongDescription>
    </Warning>
    <Warning Type="CloneableNoSuperCall">
      <Title>The clone() method does not call super.clone()</Title>
      <Description>Method $METHOD$ does not call super.clone().</Description>
      <LongDescription><![CDATA[This non-final class defines a $METHOD$ method that does not call <code>super.clone()</code>. If this class $TYPE$ is extended by a subclass (<code>$TYPE:name$Sub</code>), 
      and the subclass <code>$TYPE:name$Sub</code> calls <code>super.clone()</code>, 
      then it is likely that <code>$TYPE:name$Sub</code>'s <code>clone()</code> method will return an object of type $TYPE$, which violates the standard contract for <code>clone()</code>.<br>
      If all <code>clone()</code> methods call <code>super.clone()</code>, then they are guaranteed to use <code>Object.clone()</code>, which always returns an object of the correct type.]]></LongDescription>
    </Warning>
    <Warning Type="NotCloneableHasClone">
      <Title>Class defines clone() but doesn't implement Cloneable</Title>
      <Description>Class $TYPE$ defines clone() but doesn't implement Cloneable.</Description>
      <LongDescription><![CDATA[This class defines a $METHOD$ method but the class doesn't implement <code>Cloneable</code>. This could be confusing for the users of this class.]]></LongDescription>
    </Warning>
    <Warning Type="SyncOnGetClass">
      <Title>Synchronization on getClass() rather than class literal</Title>
      <Description>Synchronization on $RETURN_VALUE_OF$ rather than class literal.</Description>
      <LongDescription><![CDATA[This instance method synchronizes like <code>synchronized(this.getClass()) {...}</code>. 
      If this class is subclassed, subclasses will synchronize on the class object for the subclass, which isn't likely what was intended.<br>
      Consider synchronizing on concrete class literal instead: <code>synchronized($TYPE:name$.class) {...}</code>.]]></LongDescription>
    </Warning>
    <Warning Type="UselessEasyMockCall">
      <Title>Useless call to EasyMock method</Title>
      <Description>Useless call to $CALLED_METHOD$.</Description>
      <LongDescription><![CDATA[This code calls EasyMock method $CALLED_METHOD$ with empty argument. Such call will do nothing.]]></LongDescription>
    </Warning>
    <Warning Type="ReturnValueOfRead">
      <Title>Return value of read() method is not checked</Title>
      <Description>Return value of $RETURN_VALUE_OF$ is not checked.</Description>
      <LongDescription><![CDATA[This code calls $RETURN_VALUE_OF$, but does not check its return value. By contract, this method may read less
      data that requested and returns the number of bytes or characters which were actually read. Without checking the return value it's
      not possible to reliably tell how many bytes or characters were actually read.]]></LongDescription>
    </Warning>
    <Warning Type="ReturnValueOfSkip">
      <Title>Return value of skip() method is not checked</Title>
      <Description>Return value of $RETURN_VALUE_OF$ is not checked.</Description>
      <LongDescription><![CDATA[This code calls $RETURN_VALUE_OF$, but does not check its return value. By contract, this method may skip less
      data that requested and returns the number of bytes or characters which were actually skipped. Without checking the return value it's
      not possible to reliably tell how many bytes or characters were actually skipped.]]></LongDescription>
    </Warning>
    <Warning Type="NullCheckMethodForConstant">
      <Title>Null-check method called with constant non-null argument</Title>
      <Description>$CALLED_METHOD$ called with constant argument.</Description>
      <LongDescription><![CDATA[This code calls $CALLED_METHOD$ which checks the argument for null.
      However it's statically known that constant non-null argument is passed, so this check will always succeed.]]></LongDescription>
    </Warning>
    <Warning Type="WrongArgumentOrder">
      <Title>Arguments order seems to be wrong</Title>
      <Description>$CALLED_METHOD$ called with wrong argument order.</Description>
      <LongDescription><![CDATA[This code calls $CALLED_METHOD$ which checks the argument for null and fails with given message
      if the check is not satisfied. However it seems that message argument and object argument are mistakenly swapped which
      makes this check useless.]]></LongDescription>
    </Warning>
    <Warning Type="UncalledPrivateMethod">
      <Title>Private method is never called</Title>
      <Description>The method $METHOD$ is private and never called.</Description>
      <LongDescription><![CDATA[The private method $METHOD$ is never explicitly called and probably should be removed.
      If it's designed to be called via reflection or via method handles API, 
      it's a good practice to annotate it by some annotation which will explicitly signal that the method is necessary.]]></LongDescription>
    </Warning>
    <Warning Type="UncalledPrivateMethodChain">
      <Title>The chain of private methods is never called</Title>
      <Description>The method $METHOD$ along with some other methods is never called.</Description>
      <LongDescription><![CDATA[The private method $METHOD$ along with some other private methods form a chain which is never called
      (though the methods in the chain may call each other). Probably the whole chain should be removed.
      If it's designed to be called via reflection or via method handles API, 
      it's a good practice to annotate it by some annotation which will explicitly signal that the method is necessary.]]></LongDescription>
    </Warning>
    <Warning Type="ArrayIndexNegative">
      <Title>Negative array index or length used</Title>
      <Description>Negative array index or length used: $NUMBER$.</Description>
      <LongDescription><![CDATA[This code uses $NUMBER$ to specify array index, offset or length. This would result
      	in <code>IndexOutOfBoundsException</code> exception in runtime.]]></LongDescription>
    </Warning>
    <Warning Type="ArrayIndexOutOfRange">
      <Title>Array index is out of bounds</Title>
      <Description>Used array index $NUMBER$ exceeds or equals to possible array length $MAX_LENGTH$.</Description>
      <LongDescription><![CDATA[This code uses $NUMBER$ to specify array index. However it's statically known that given array
        length do not exceed $MAX_LENGTH$. This would result in <code>ArrayIndexOutOfBoundsException</code> in runtime.]]></LongDescription>
    </Warning>
    <Warning Type="ArrayOffsetOutOfRange">
      <Title>Array offset is out of bounds</Title>
      <Description>Used array offset $NUMBER$ exceeds possible array length $MAX_LENGTH$.</Description>
      <LongDescription><![CDATA[This code uses $NUMBER$ to specify array offset. However it's statically known that given array
        length do not exceed $MAX_LENGTH$. This would result in <code>IndexOutOfBoundsException</code> in runtime.]]></LongDescription>
    </Warning>
    <Warning Type="ArrayLengthOutOfRange">
      <Title>Array length is out of bounds</Title>
      <Description>Specified array length $NUMBER$ exceeds maximal possible value $MAX_LENGTH$.</Description>
      <LongDescription><![CDATA[This code specifies length = $NUMBER$, but it's statically known that given array
        length should not exceed $MAX_LENGTH$. This would result in <code>IndexOutOfBoundsException</code> in runtime.]]></LongDescription>
    </Warning>
    <Warning Type="ContravariantArrayStore">
      <Title>Contravariant store to an array</Title>
      <Description>Attempt to store value of type $VALUE_TYPE$ to an array of type $ARRAY_TYPE$.</Description>
      <LongDescription><![CDATA[This code stores the value of type $VALUE_TYPE$ into an array of type $ARRAY_TYPE$.
      It seems that these types are incompatible, thus this operation may cause <code>ArrayStoreException</code> at runtime.]]></LongDescription>
    </Warning>
    <Warning Type="FieldDoubleAssignment">
      <Title>Field is assigned twice</Title>
      <Description>The field $FIELD$ is assigned twice in a row.</Description>
      <LongDescription><![CDATA[This code assigns the value to the field $FIELD$ twice in a row making the first assignment useless.
      Probably something else was intended.]]></LongDescription>
    </Warning>
    <Warning Type="UnusedPublicField">
      <Title>Public or protected field is unused</Title>
      <Description>Public or protected field $FIELD$ is unused.</Description>
      <LongDescription><![CDATA[The field $FIELD$ is unused and could be removed. False positive is possible if it's intended to be used
      in the code which is out of the scope of this analysis or used via reflection.]]></LongDescription>
    </Warning>
    <Warning Type="UnusedPrivateField">
      <Title>Private or package-private field is unused</Title>
      <Description>Private or package-private field $FIELD$ is unused.</Description>
      <LongDescription><![CDATA[The field $FIELD$ is unused and could be removed. If it's intended to be used via reflection, consider annotating it
      with some annotation to avoid confusion.]]></LongDescription>
    </Warning>
    <Warning Type="UnreadPublicField">
      <Title>Public or protected field is never read</Title>
      <Description>Public or protected field $FIELD$ is written, but never read.</Description>
      <LongDescription><![CDATA[The field $FIELD$ is written, but never read, so probably it should be removed. 
      False positive is possible if it's intended to be read in the code which is out of the scope of this analysis 
      or used via reflection.]]></LongDescription>
    </Warning>
    <Warning Type="UnreadPrivateField">
      <Title>Private or package-private field is never read</Title>
      <Description>Private or package-private field $FIELD$ is is written, but never read.</Description>
      <LongDescription><![CDATA[The field $FIELD$ is written, but never read, so probably it should be removed. 
      If it's intended to be read via reflection, consider annotating it with some annotation to avoid confusion.]]></LongDescription>
    </Warning>
    <Warning Type="FieldShouldBeStatic">
      <Title>Non-static final field is initialized to a static value</Title>
      <Description>Non-static final field $FIELD$ is initialized to a static value.</Description>
      <LongDescription><![CDATA[The final field $FIELD$ is initialized to a statically known value.
      Consider making this field static.]]></LongDescription>
    </Warning>
    <Warning Type="FieldUsedInSingleMethod">
      <Title>Field could be refactored to local variable</Title>
      <Description>Field $FIELD$ could be refactored to local variable.</Description>
      <LongDescription><![CDATA[Analysis discovers that field $FIELD$ is used only inside method $METHOD$ and
      the value stored after method execution is never used again. Consider converting this field into local variable 
      to reduce the object footprint and possibly limit the lifespan of stored object.]]></LongDescription>
    </Warning>
    <Warning Type="UnwrittenPublicField">
      <Title>Public or protected field is used, but never written</Title>
      <Description>Public or protected field $FIELD$ is used, but never written.</Description>
      <LongDescription><![CDATA[The field $FIELD$ is used, but never written, so it always has default value. 
      False positive is possible if it's intended to be written in the code which is out of the scope of this analysis 
      or written via reflection.]]></LongDescription>
    </Warning>
    <Warning Type="UnwrittenPrivateField">
      <Title>Private or package-private field is used, but never written</Title>
      <Description>Private or package-private field $FIELD$ is used, but never written.</Description>
      <LongDescription><![CDATA[The field $FIELD$ is used, but never written, so it always has default value. 
      If it's intended to be written (injected) via reflection, consider annotating it with some annotation to avoid confusion.]]></LongDescription>
    </Warning>
    <Warning Type="FieldIsAlwaysNull">
      <Title>Field only ever set to null</Title>
      <Description>Field $FIELD$ only ever set to null.</Description>
      <LongDescription><![CDATA[All writes to this field $FIELD$ are of the constant value <code>null</code>, 
      and thus all reads of the field will return <code>null</code>. Probably something else was meant or this field can be removed. 
      If it's intended to be written (injected) via reflection, consider annotating it with some annotation to avoid confusion.]]></LongDescription>
    </Warning>
    <Warning Type="InitializerRefersSubclass">
      <Title>Class initializer refers to subclass</Title>
      <Description>Initializer of $TYPE$ refers to its subclass $SUBCLASS$.</Description>
      <LongDescription><![CDATA[The class initializer of $TYPE$ may trigger the initialization of its subclass $SUBCLASS$.
      This might cause JVM-level deadlock when both classes are initialized simultaneously from different threads.]]></LongDescription>
    </Warning>
    <Warning Type="RedundantStreamForEach">
      <Title>Redundant stream created just to call forEach.</Title>
      <Description>Redundant stream created just to call $CALLED_METHOD$ in $METHOD$.</Description>
      <LongDescription><![CDATA[This code creates a stream upon collection just to call $CALLED_METHOD$.
      It's shorter and usually more efficient to call $REPLACEMENT$ directly on the collection.
      Note that sometimes <code>collection.stream().forEach()</code> and <code>collection.forEach()</code> have different semantics.
      For example, for <code>Collections.synchronizedXYZ</code> collections <code>stream().forEach()</code> is not synchronized,
      but <code>forEach()</code> is synchronized.]]></LongDescription>
    </Warning>
    <Warning Type="RedundantStreamFind">
      <Title>Redundant filter().findFirst().isPresent() chain.</Title>
      <Description>Redundant filter().findFirst().isPresent() chain in $METHOD$.</Description>
      <LongDescription><![CDATA[This code tries to check whether stream contains element matching the predicate
      using the sequence like <code>filter(predicate).findFirst().isPresent()</code>. There's dedicated method
      for such sequence: $REPLACEMENT$. Simply use <code>anyMatch(predicate)</code>.]]></LongDescription>
    </Warning>
  </WarningList>
</p:Messages>
